#!/usr/bin/env ruby

# Download iPlayer programmes by spoofing an iPhone
# Paul Battley - http://po-ru.com/
#
# Get the latest version via subversion:
# svn co http://paulbattley.googlecode.com/svn/iplayer-dl

require 'iplayer'
require 'optparse'
require 'fileutils'

include IPlayer
include IPlayer::Errors

OPTIONS = {
  :type_preference  => %w[original signed],
  :download_path    => Dir.pwd,
  :http_proxy       => ENV['http_proxy']
}

opts = ARGV.options{ |o|
  o.banner << ' IDENTIFIER [IDENTIFIER [...]]'
  o.define_head 'Download DRM-free videos from the BBC iPlayer, courtesy of their iPhone interface.'
  o.separator 'IDENTIFIER is the iPlayer viewing page URL or the PID of the programme.'
  o.separator ''
  o.on(
    '-t', '--type-preference=VERSION', String,
    'Video types in order of preference.',
    "Default is '#{OPTIONS[:type_preference].join(',')}'."
  ) { |s| OPTIONS[:type_preference] = s.split(/,\s*/) }
  o.on(
    '-d', '--download-path=PATH', String,
    'Location into which downloaded files will be saved.',
    'Default is current working directory.'
  ) { |OPTIONS[:download_path]| }
  o.on(
    '-s', '--title-subdir',
    'Place downloaded files in a sub-directory named after the title of the programme.'
  ) { OPTIONS[:subdirs] = true }
  o.on(
    '-f', '--filename=FILENAME', String,
    'Manually specify a name for the downloaded file.',
    'The default is constructed from the programme metadata.',
    'Do not use this with multiple downloads!'
  ) { |OPTIONS[:filename]| }
  o.on(
    '-p', '--http-proxy=HOST:PORT', String,
    'Specify an HTTP proxy.',
    'Default is taken from the http_proxy environment variable.'
  ) { |OPTIONS[:http_proxy]| }
  o.on(
    '-l', '--pid-list=FILENAME', String,
    'List PIDs to be downloaded in a file, one per line.'
  ) { |OPTIONS[:pid_list]| }
  o.on_tail(
    '-h', '--help', 
    'Show this help message.'
  ) { puts o; exit }
}

begin
  opts.parse!
  pids = ARGV
  if OPTIONS[:pid_list]
    pids += File.read(OPTIONS[:pid_list]).strip.split(/\s*\r?\n\s*/)
  end
  raise 'no programme identifier specified' if pids.empty?
  raise 'specifying the file name does not work with multiple downloads' if OPTIONS[:filename] && pids.length > 1
rescue => exception
  $stderr.puts 'Error: '+exception, ''
  puts opts
  exit 1
end

if http_proxy = OPTIONS[:http_proxy]
  http_proxy = 'http://' + http_proxy unless http_proxy =~ %r{^http://}
  u = URI.parse(http_proxy)
  $stderr.puts "Using proxy #{u.host}:#{u.port}"
  http = Net::HTTP::Proxy(u.host, u.port)
else
  http = Net::HTTP
end

pids.each do |pid|
  if pid =~ %r!/(?:item|episode)/([a-z0-9]{8})!
    pid = $1
  end

  browser = Browser.new(http)
  downloader = Downloader.new(browser, pid)

  begin
    available_versions = downloader.available_versions
    raise MP4Unavailable if available_versions.empty?
    version = available_versions.sort_by{ |v| 
      OPTIONS[:type_preference].index(v.name) || 100 
    }.first

    filename = OPTIONS[:filename]
    if filename.nil? || OPTIONS[:subdirs]
      metadata = Metadata.new(pid, browser)
      filename ||= "#{ metadata.full_title }.mov".gsub(/[^a-z0-9 \-\.]+/i, '')
    end
    if OPTIONS[:subdirs]
      subdir = metadata.title.gsub(/[^a-z0-9 \-\.]+/i, '')
      path = File.expand_path( File.join( OPTIONS[:download_path], subdir ))
      FileUtils.makedirs(path)
      path = File.join( path, filename )
    else
      path = File.expand_path( File.join( OPTIONS[:download_path], filename ))
    end

    old_percentage = nil
    if File.exist?(path)
      offset = File.size(path)
      $stderr.puts "Resuming download at #{offset} bytes."
    else
      offset = 0
    end

    $stderr.puts "#{ filename } (#{ version.name })"
    File.open(path, 'a+b') do |io|
      downloader.download(version.pid, io, offset) do |position, max|
        percentage = "%.1f" % [((1000 * position) / max) / 10.0]
        if percentage != old_percentage
          old_percentage = percentage
          $stderr.print "\r#{ percentage }%"
          $stderr.flush
        end
      end
    end
    $stderr.puts

  rescue RecognizedError => error
    $stderr.puts(error.to_s)
    next
  end
end
