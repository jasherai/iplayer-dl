#!/usr/bin/env ruby

# Download iPlayer programmes by spoofing an iPhone
# Paul Battley - http://po-ru.com/

require 'net/http'
require 'uri'
require 'date'
require 'rexml/document'

# Used by Safari Mobile
IPHONE_UA  = 'Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en) AppleWebKit/420+ '+
             '(KHTML, like Gecko) Version/3.0 Mobile/1A543a Safari/419.3'

# Used by Quicktime
QT_UA      = 'Apple iPhone v1.1.4 CoreMedia v1.0.0.4A102'

# Most people will prefer the non-sign-language version
TYPE_PREFERENCE = %w[Original Signed]

PROGRAMME_URL = 'http://www.bbc.co.uk/iplayer/page/item/%s.shtml'
METADATA_URL  = 'http://www.bbc.co.uk/iplayer/metafiles/episode/%s.xml'

if http_proxy = ENV['http_proxy']
  proxy_url = URI.parse(http_proxy)
  HTTP = Net::HTTP::Proxy(proxy_url.host, proxy_url.port)
else
  HTTP = Net::HTTP
end

DEFAULT_HEADERS = {
  'Accept'          => '*/*',
  'Accept-Language' => 'en',
  'Accept-Encoding' => 'gzip, deflate',
  'Connection'      => 'keep-alive',
  'Pragma'          => 'no-cache'
}

class Net::HTTPResponse # Monkey-patch in some 21st-century functionality
  include Enumerable
  
  def cookies
    inject([]){ |acc, (key, value)|
      key == 'set-cookie' ? acc << value.split(/;/).first : acc
    }
  end
  
  def to_hash
    @to_hash ||= inject({}){ |hash, (key, value)|
      hash[key] = value
      hash
    }
  end
end

def http_get(location, headers={}, &blk)
  url = URI.parse(location)
  http = HTTP.new(url.host, url.port)
  path = url.path
  if url.query
    path << '?' << url.query
  end
  http.request_get(path, DEFAULT_HEADERS.merge(headers), &blk)
end

def js_date(digit_string)
  digits = digit_string.scan(/\d+/).map{ |d| d.to_i }
  digits[1] += 1 # Zero-indexed months
  DateTime.civil(*digits)
end

page_url = ARGV[0]
if page_url =~ /^[a-z0-9]{8}$/
  page_url = PROGRAMME_URL % page_url
end

unless page_url
  puts "Download DRM-free videos from the BBC iPlayer, courtesy of their iPhone interface."
  puts
  puts "Usage: #{$0} PROGRAMME"
  puts "Where PROGRAMME is the iPlayer viewing page or the PID of the programme."
  exit 1
end

# Get the actual programme page
response = http_get( page_url,
                     'User-Agent' => IPHONE_UA )
cookies = response.cookies.join('; ')
html = response.body

# Poor man's JavaScript parser to evaluate the multiple versions
begin
  versions = html[/ iplayer\.versions \s* = \s* \[ .*? \]; /mx].split(/\},\s*\{/)
  pid      = html[/ iplayer\.pid \s* = \s* '([a-z0-9]{8})' /x, 1]
rescue
  $stderr.puts "The BBC iPlayer appears to have changed.",
               "Please look for an updated version of this script."
  exit 1
end
# Find out which versions are available right now
available_versions = versions.inject({}){ |a, e|
  begin
    type = e[/ type \s* : \s* ' ( [^']+ ) ' /x, 1]
    vpid = e[/ pid  \s* : \s* ' ( [^']+ ) ' /x, 1]
    mp4  = e[/ iplayer_streaming_http_mp4 \s* : \s* \[ ( [^\]]+ ) /x, 1]
    mp4_start = js_date(mp4[/ start \s* : \s* new \s+ Date\( ( [^\)]+ ) /x, 1])
    mp4_end   = js_date(mp4[/ end   \s* : \s* new \s+ Date\( ( [^\)]+ ) /x, 1])
    now = DateTime.now
    if (now >= mp4_start && now <= mp4_end)
      a[type] = vpid
    end
  rescue
  end
  a
}
if available_versions.empty?
  $stderr.puts "This programme is not currently available in an MP4 version."
  exit 1
end
type, version_pid = available_versions.sort_by{ |t, p| TYPE_PREFERENCE.index(t) || 100 }.first

# Fetch the metadata
metadata = REXML::Document.new( http_get(METADATA_URL % pid).body )
title    = REXML::XPath.first(metadata, '//iplayerMedia/concept/title').text
subtitle = REXML::XPath.first(metadata, '//iplayerMedia/concept/subtitle').text rescue nil
title << ' - ' << subtitle if subtitle

# Get the auth URL
r = (rand * 10000000).floor
selector = "http://www.bbc.co.uk/mediaselector/3/auth/iplayer_streaming_http_mp4/#{ version_pid }?#{r}"
response = http_get( selector, 
                     'Cookie'     => cookies,
                     'User-Agent' => QT_UA,
                     'Range'      => 'bytes=0-1' )

# It redirects us to the real stream location
location = response.to_hash['location']
if location =~ /error\.shtml/
  $stderr.puts "This file does not appear to be available."
  exit 1
end

response = http_get( location,
                     'Cookie'     => cookies,
                     'User-Agent' => QT_UA,
                     'Range'      => 'bytes=0-1' )

# We now know the full length of the content
max = response.to_hash['content-range'][/\d+$/].to_i

old_percentage = nil
filename = "#{ title }.mov".gsub(/[^a-z0-9 \-\.]+/i, '')
if File.exist?(filename)
  start = File.size(filename)
  puts "Resuming download." if $stdout.tty?
else
  start = 0
end
bytes_got = start

File.open(filename, 'a+b') do |io|
  http_get( location,
            'Cookie'     => cookies,
            'User-Agent' => QT_UA,
            'Range'      => "bytes=#{start}-" ) do |response|
    response.read_body do |data|
      bytes_got += data.length
      percentage = "%.1f" % [((1000 * bytes_got) / max) / 10.0]
      if percentage != old_percentage
        old_percentage = percentage
        if $stdout.tty?
          print "\r#{ percentage }% #{ filename } (#{ type })"
          $stdout.flush
        end
      end
      io << data
    end
  end
end
puts if $stdout.tty?
